// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (offense_id, user_id, amount, proof_type, proof_url)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, offense_id, user_id, amount, proof_type, proof_url, verified, verified_by, created_at, updated_at
`

type CreatePaymentParams struct {
	OffenseID int32          `db:"offense_id" json:"offense_id"`
	UserID    int32          `db:"user_id" json:"user_id"`
	Amount    pgtype.Numeric `db:"amount" json:"amount"`
	ProofType pgtype.Text    `db:"proof_type" json:"proof_type"`
	ProofUrl  pgtype.Text    `db:"proof_url" json:"proof_url"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.OffenseID,
		arg.UserID,
		arg.Amount,
		arg.ProofType,
		arg.ProofUrl,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OffenseID,
		&i.UserID,
		&i.Amount,
		&i.ProofType,
		&i.ProofUrl,
		&i.Verified,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT id, offense_id, user_id, amount, proof_type, proof_url, verified, verified_by, created_at, updated_at
FROM payments
WHERE id = $1
`

func (q *Queries) GetPayment(ctx context.Context, id int32) (Payment, error) {
	row := q.db.QueryRow(ctx, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OffenseID,
		&i.UserID,
		&i.Amount,
		&i.ProofType,
		&i.ProofUrl,
		&i.Verified,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPaymentsForOffense = `-- name: ListPaymentsForOffense :many
SELECT id, offense_id, user_id, amount, proof_type, proof_url, verified, verified_by, created_at, updated_at
FROM payments
WHERE offense_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentsForOffense(ctx context.Context, offenseID int32) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsForOffense, offenseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.OffenseID,
			&i.UserID,
			&i.Amount,
			&i.ProofType,
			&i.ProofUrl,
			&i.Verified,
			&i.VerifiedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsForUser = `-- name: ListPaymentsForUser :many
SELECT p.id, p.offense_id, p.user_id, p.amount, p.proof_type, p.proof_url, p.verified, p.verified_by, p.created_at, p.updated_at,
       o.jar_id, tj.name as jar_name, ot.name as offense_type_name
FROM payments p
INNER JOIN offenses o ON p.offense_id = o.id
INNER JOIN tip_jars tj ON o.jar_id = tj.id
INNER JOIN offense_types ot ON o.offense_type_id = ot.id
WHERE p.user_id = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentsForUserParams struct {
	UserID int32 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListPaymentsForUserRow struct {
	ID              int32            `db:"id" json:"id"`
	OffenseID       int32            `db:"offense_id" json:"offense_id"`
	UserID          int32            `db:"user_id" json:"user_id"`
	Amount          pgtype.Numeric   `db:"amount" json:"amount"`
	ProofType       pgtype.Text      `db:"proof_type" json:"proof_type"`
	ProofUrl        pgtype.Text      `db:"proof_url" json:"proof_url"`
	Verified        bool             `db:"verified" json:"verified"`
	VerifiedBy      pgtype.Int4      `db:"verified_by" json:"verified_by"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	JarID           int32            `db:"jar_id" json:"jar_id"`
	JarName         string           `db:"jar_name" json:"jar_name"`
	OffenseTypeName string           `db:"offense_type_name" json:"offense_type_name"`
}

func (q *Queries) ListPaymentsForUser(ctx context.Context, arg ListPaymentsForUserParams) ([]ListPaymentsForUserRow, error) {
	rows, err := q.db.Query(ctx, listPaymentsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPaymentsForUserRow
	for rows.Next() {
		var i ListPaymentsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OffenseID,
			&i.UserID,
			&i.Amount,
			&i.ProofType,
			&i.ProofUrl,
			&i.Verified,
			&i.VerifiedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JarID,
			&i.JarName,
			&i.OffenseTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const verifyPayment = `-- name: VerifyPayment :one
UPDATE payments
SET verified = true, verified_by = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, offense_id, user_id, amount, proof_type, proof_url, verified, verified_by, created_at, updated_at
`

type VerifyPaymentParams struct {
	ID         int32       `db:"id" json:"id"`
	VerifiedBy pgtype.Int4 `db:"verified_by" json:"verified_by"`
}

func (q *Queries) VerifyPayment(ctx context.Context, arg VerifyPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, verifyPayment, arg.ID, arg.VerifiedBy)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OffenseID,
		&i.UserID,
		&i.Amount,
		&i.ProofType,
		&i.ProofUrl,
		&i.Verified,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
