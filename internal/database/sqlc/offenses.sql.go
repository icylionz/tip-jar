// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: offenses.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOffense = `-- name: CreateOffense :one
INSERT INTO offenses (jar_id, offense_type_id, reporter_id, offender_id, notes, cost_override)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, jar_id, offense_type_id, reporter_id, offender_id, notes, cost_override, status, created_at, updated_at
`

type CreateOffenseParams struct {
	JarID         int32          `db:"jar_id" json:"jar_id"`
	OffenseTypeID int32          `db:"offense_type_id" json:"offense_type_id"`
	ReporterID    int32          `db:"reporter_id" json:"reporter_id"`
	OffenderID    int32          `db:"offender_id" json:"offender_id"`
	Notes         pgtype.Text    `db:"notes" json:"notes"`
	CostOverride  pgtype.Numeric `db:"cost_override" json:"cost_override"`
}

func (q *Queries) CreateOffense(ctx context.Context, arg CreateOffenseParams) (Offense, error) {
	row := q.db.QueryRow(ctx, createOffense,
		arg.JarID,
		arg.OffenseTypeID,
		arg.ReporterID,
		arg.OffenderID,
		arg.Notes,
		arg.CostOverride,
	)
	var i Offense
	err := row.Scan(
		&i.ID,
		&i.JarID,
		&i.OffenseTypeID,
		&i.ReporterID,
		&i.OffenderID,
		&i.Notes,
		&i.CostOverride,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJarBalancesByUnit = `-- name: GetJarBalancesByUnit :many
SELECT 
    u.id as user_id,
    u.name as user_name,
    u.avatar,
    COALESCE(ot.cost_unit, 'items') as unit,
    COALESCE(SUM(
        CASE 
            WHEN o.cost_override IS NOT NULL THEN o.cost_override
            ELSE ot.cost_amount
        END
    ), 0) as total_owed,
    COUNT(*) as offense_count
FROM users u
INNER JOIN jar_memberships jm ON u.id = jm.user_id
LEFT JOIN offenses o ON u.id = o.offender_id AND o.jar_id = $1 AND o.status = 'pending'
LEFT JOIN offense_types ot ON o.offense_type_id = ot.id
WHERE jm.jar_id = $1
GROUP BY u.id, u.name, u.avatar, ot.cost_unit
HAVING COUNT(o.id) > 0 OR ot.cost_unit IS NULL
ORDER BY u.name, total_owed DESC
`

type GetJarBalancesByUnitRow struct {
	UserID       int32       `db:"user_id" json:"user_id"`
	UserName     string      `db:"user_name" json:"user_name"`
	Avatar       pgtype.Text `db:"avatar" json:"avatar"`
	Unit         string      `db:"unit" json:"unit"`
	TotalOwed    interface{} `db:"total_owed" json:"total_owed"`
	OffenseCount int64       `db:"offense_count" json:"offense_count"`
}

func (q *Queries) GetJarBalancesByUnit(ctx context.Context, jarID int32) ([]GetJarBalancesByUnitRow, error) {
	rows, err := q.db.Query(ctx, getJarBalancesByUnit, jarID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJarBalancesByUnitRow
	for rows.Next() {
		var i GetJarBalancesByUnitRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.Avatar,
			&i.Unit,
			&i.TotalOwed,
			&i.OffenseCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffense = `-- name: GetOffense :one
SELECT id, jar_id, offense_type_id, reporter_id, offender_id, notes, cost_override, status, created_at, updated_at
FROM offenses
WHERE id = $1
`

func (q *Queries) GetOffense(ctx context.Context, id int32) (Offense, error) {
	row := q.db.QueryRow(ctx, getOffense, id)
	var i Offense
	err := row.Scan(
		&i.ID,
		&i.JarID,
		&i.OffenseTypeID,
		&i.ReporterID,
		&i.OffenderID,
		&i.Notes,
		&i.CostOverride,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserBalanceInJar = `-- name: GetUserBalanceInJar :one
SELECT 
    COALESCE(SUM(
        CASE 
            WHEN o.cost_override IS NOT NULL THEN o.cost_override
            ELSE ot.cost_amount
        END
    ), 0) as total_owed
FROM offenses o
INNER JOIN offense_types ot ON o.offense_type_id = ot.id
WHERE o.jar_id = $1 AND o.offender_id = $2 AND o.status = 'pending'
`

type GetUserBalanceInJarParams struct {
	JarID      int32 `db:"jar_id" json:"jar_id"`
	OffenderID int32 `db:"offender_id" json:"offender_id"`
}

func (q *Queries) GetUserBalanceInJar(ctx context.Context, arg GetUserBalanceInJarParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserBalanceInJar, arg.JarID, arg.OffenderID)
	var total_owed interface{}
	err := row.Scan(&total_owed)
	return total_owed, err
}

const getUserBalancesByUnitInJar = `-- name: GetUserBalancesByUnitInJar :many
SELECT 
    COALESCE(ot.cost_unit, 'items') as unit,
    COALESCE(SUM(
        CASE 
            WHEN o.cost_override IS NOT NULL THEN o.cost_override
            ELSE ot.cost_amount
        END
    ), 0) as total_owed,
    COUNT(*) as offense_count
FROM offenses o
INNER JOIN offense_types ot ON o.offense_type_id = ot.id
WHERE o.jar_id = $1 AND o.offender_id = $2 AND o.status = 'pending'
GROUP BY ot.cost_unit
ORDER BY total_owed DESC
`

type GetUserBalancesByUnitInJarParams struct {
	JarID      int32 `db:"jar_id" json:"jar_id"`
	OffenderID int32 `db:"offender_id" json:"offender_id"`
}

type GetUserBalancesByUnitInJarRow struct {
	Unit         string      `db:"unit" json:"unit"`
	TotalOwed    interface{} `db:"total_owed" json:"total_owed"`
	OffenseCount int64       `db:"offense_count" json:"offense_count"`
}

func (q *Queries) GetUserBalancesByUnitInJar(ctx context.Context, arg GetUserBalancesByUnitInJarParams) ([]GetUserBalancesByUnitInJarRow, error) {
	rows, err := q.db.Query(ctx, getUserBalancesByUnitInJar, arg.JarID, arg.OffenderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBalancesByUnitInJarRow
	for rows.Next() {
		var i GetUserBalancesByUnitInJarRow
		if err := rows.Scan(&i.Unit, &i.TotalOwed, &i.OffenseCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOffensesForJar = `-- name: ListOffensesForJar :many
SELECT o.id, o.jar_id, o.offense_type_id, o.reporter_id, o.offender_id, o.notes, o.cost_override, o.status, o.created_at, o.updated_at,
       ot.name as offense_type_name, ot.cost_amount, ot.cost_unit,
       reporter.name as reporter_name, offender.name as offender_name
FROM offenses o
INNER JOIN offense_types ot ON o.offense_type_id = ot.id
INNER JOIN users reporter ON o.reporter_id = reporter.id
INNER JOIN users offender ON o.offender_id = offender.id
WHERE o.jar_id = $1
ORDER BY o.created_at DESC
LIMIT $2 OFFSET $3
`

type ListOffensesForJarParams struct {
	JarID  int32 `db:"jar_id" json:"jar_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListOffensesForJarRow struct {
	ID              int32            `db:"id" json:"id"`
	JarID           int32            `db:"jar_id" json:"jar_id"`
	OffenseTypeID   int32            `db:"offense_type_id" json:"offense_type_id"`
	ReporterID      int32            `db:"reporter_id" json:"reporter_id"`
	OffenderID      int32            `db:"offender_id" json:"offender_id"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CostOverride    pgtype.Numeric   `db:"cost_override" json:"cost_override"`
	Status          string           `db:"status" json:"status"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	OffenseTypeName string           `db:"offense_type_name" json:"offense_type_name"`
	CostAmount      pgtype.Numeric   `db:"cost_amount" json:"cost_amount"`
	CostUnit        pgtype.Text      `db:"cost_unit" json:"cost_unit"`
	ReporterName    string           `db:"reporter_name" json:"reporter_name"`
	OffenderName    string           `db:"offender_name" json:"offender_name"`
}

func (q *Queries) ListOffensesForJar(ctx context.Context, arg ListOffensesForJarParams) ([]ListOffensesForJarRow, error) {
	rows, err := q.db.Query(ctx, listOffensesForJar, arg.JarID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOffensesForJarRow
	for rows.Next() {
		var i ListOffensesForJarRow
		if err := rows.Scan(
			&i.ID,
			&i.JarID,
			&i.OffenseTypeID,
			&i.ReporterID,
			&i.OffenderID,
			&i.Notes,
			&i.CostOverride,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OffenseTypeName,
			&i.CostAmount,
			&i.CostUnit,
			&i.ReporterName,
			&i.OffenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingOffensesForUser = `-- name: ListPendingOffensesForUser :many
SELECT o.id, o.jar_id, o.offense_type_id, o.reporter_id, o.offender_id, o.notes, o.cost_override, o.status, o.created_at, o.updated_at,
       ot.name as offense_type_name, ot.cost_amount, ot.cost_unit,
       tj.name as jar_name
FROM offenses o
INNER JOIN offense_types ot ON o.offense_type_id = ot.id
INNER JOIN tip_jars tj ON o.jar_id = tj.id
WHERE o.offender_id = $1 AND o.status = 'pending'
ORDER BY o.created_at DESC
`

type ListPendingOffensesForUserRow struct {
	ID              int32            `db:"id" json:"id"`
	JarID           int32            `db:"jar_id" json:"jar_id"`
	OffenseTypeID   int32            `db:"offense_type_id" json:"offense_type_id"`
	ReporterID      int32            `db:"reporter_id" json:"reporter_id"`
	OffenderID      int32            `db:"offender_id" json:"offender_id"`
	Notes           pgtype.Text      `db:"notes" json:"notes"`
	CostOverride    pgtype.Numeric   `db:"cost_override" json:"cost_override"`
	Status          string           `db:"status" json:"status"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	OffenseTypeName string           `db:"offense_type_name" json:"offense_type_name"`
	CostAmount      pgtype.Numeric   `db:"cost_amount" json:"cost_amount"`
	CostUnit        pgtype.Text      `db:"cost_unit" json:"cost_unit"`
	JarName         string           `db:"jar_name" json:"jar_name"`
}

func (q *Queries) ListPendingOffensesForUser(ctx context.Context, offenderID int32) ([]ListPendingOffensesForUserRow, error) {
	rows, err := q.db.Query(ctx, listPendingOffensesForUser, offenderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingOffensesForUserRow
	for rows.Next() {
		var i ListPendingOffensesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.JarID,
			&i.OffenseTypeID,
			&i.ReporterID,
			&i.OffenderID,
			&i.Notes,
			&i.CostOverride,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OffenseTypeName,
			&i.CostAmount,
			&i.CostUnit,
			&i.JarName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOffenseStatus = `-- name: UpdateOffenseStatus :one
UPDATE offenses
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, jar_id, offense_type_id, reporter_id, offender_id, notes, cost_override, status, created_at, updated_at
`

type UpdateOffenseStatusParams struct {
	ID     int32  `db:"id" json:"id"`
	Status string `db:"status" json:"status"`
}

func (q *Queries) UpdateOffenseStatus(ctx context.Context, arg UpdateOffenseStatusParams) (Offense, error) {
	row := q.db.QueryRow(ctx, updateOffenseStatus, arg.ID, arg.Status)
	var i Offense
	err := row.Scan(
		&i.ID,
		&i.JarID,
		&i.OffenseTypeID,
		&i.ReporterID,
		&i.OffenderID,
		&i.Notes,
		&i.CostOverride,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
